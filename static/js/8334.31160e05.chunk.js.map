{"version":3,"file":"static/js/8334.31160e05.chunk.js","mappings":"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","sources":["../node_modules/@esri/arcgis-to-geojson-utils/index.js"],"sourcesContent":["/*\n * Copyright 2017 Esri\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// checks if 2 x,y points are equal\nfunction pointsEqual (a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// checks if the first and last points of a ring are equal and closes the ring\nfunction closeRing (coordinates) {\n  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n    coordinates.push(coordinates[0]);\n  }\n  return coordinates;\n}\n\n// determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n// points-are-in-clockwise-order\nfunction ringIsClockwise (ringToTest) {\n  var total = 0;\n  var i = 0;\n  var rLength = ringToTest.length;\n  var pt1 = ringToTest[i];\n  var pt2;\n  for (i; i < rLength - 1; i++) {\n    pt2 = ringToTest[i + 1];\n    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n    pt1 = pt2;\n  }\n  return (total >= 0);\n}\n\n// ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L504-L519\nfunction vertexIntersectsVertex (a1, a2, b1, b2) {\n  var uaT = ((b2[0] - b1[0]) * (a1[1] - b1[1])) - ((b2[1] - b1[1]) * (a1[0] - b1[0]));\n  var ubT = ((a2[0] - a1[0]) * (a1[1] - b1[1])) - ((a2[1] - a1[1]) * (a1[0] - b1[0]));\n  var uB = ((b2[1] - b1[1]) * (a2[0] - a1[0])) - ((b2[0] - b1[0]) * (a2[1] - a1[1]));\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L521-L531\nfunction arrayIntersectsArray (a, b) {\n  for (var i = 0; i < a.length - 1; i++) {\n    for (var j = 0; j < b.length - 1; j++) {\n      if (vertexIntersectsVertex(a[i], a[i + 1], b[j], b[j + 1])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// ported from terraformer.js https://github.com/Esri/Terraformer/blob/master/terraformer.js#L470-L480\nfunction coordinatesContainPoint (coordinates, point) {\n  var contains = false;\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if (((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1]) ||\n         (coordinates[j][1] <= point[1] && point[1] < coordinates[i][1])) &&\n        (point[0] < (((coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1])) / (coordinates[j][1] - coordinates[i][1])) + coordinates[i][0])) {\n      contains = !contains;\n    }\n  }\n  return contains;\n}\n\n// ported from terraformer-arcgis-parser.js https://github.com/Esri/terraformer-arcgis-parser/blob/master/terraformer-arcgis-parser.js#L106-L113\nfunction coordinatesContainCoordinates (outer, inner) {\n  var intersects = arrayIntersectsArray(outer, inner);\n  var contains = coordinatesContainPoint(outer, inner[0]);\n  if (!intersects && contains) {\n    return true;\n  }\n  return false;\n}\n\n// do any polygons in this array contain any other polygons in this array?\n// used for checking for holes in arcgis rings\n// ported from terraformer-arcgis-parser.js https://github.com/Esri/terraformer-arcgis-parser/blob/master/terraformer-arcgis-parser.js#L117-L172\nfunction convertRingsToGeoJSON (rings) {\n  var outerRings = [];\n  var holes = [];\n  var x; // iterator\n  var outerRing; // current outer ring being evaluated\n  var hole; // current hole being evaluated\n\n  // for each ring\n  for (var r = 0; r < rings.length; r++) {\n    var ring = closeRing(rings[r].slice(0));\n    if (ring.length < 4) {\n      continue;\n    }\n    // is this ring an outer ring? is it clockwise?\n    if (ringIsClockwise(ring)) {\n      var polygon = [ ring.slice().reverse() ]; // wind outer rings counterclockwise for RFC 7946 compliance\n      outerRings.push(polygon); // push to outer rings\n    } else {\n      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance\n    }\n  }\n\n  var uncontainedHoles = [];\n\n  // while there are holes left...\n  while (holes.length) {\n    // pop a hole off out stack\n    hole = holes.pop();\n\n    // loop over all outer rings and see if they contain our hole.\n    var contained = false;\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n      if (coordinatesContainCoordinates(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        contained = true;\n        break;\n      }\n    }\n\n    // ring is not contained in any outer ring\n    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n    if (!contained) {\n      uncontainedHoles.push(hole);\n    }\n  }\n\n  // if we couldn't match any holes using contains we can try intersects...\n  while (uncontainedHoles.length) {\n    // pop a hole off out stack\n    hole = uncontainedHoles.pop();\n\n    // loop over all outer rings and see if any intersect our hole.\n    var intersects = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n      if (arrayIntersectsArray(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        intersects = true;\n        break;\n      }\n    }\n\n    if (!intersects) {\n      outerRings.push([hole.reverse()]);\n    }\n  }\n\n  if (outerRings.length === 1) {\n    return {\n      type: 'Polygon',\n      coordinates: outerRings[0]\n    };\n  } else {\n    return {\n      type: 'MultiPolygon',\n      coordinates: outerRings\n    };\n  }\n}\n\n// This function ensures that rings are oriented in the right directions\n// outer rings are clockwise, holes are counterclockwise\n// used for converting GeoJSON Polygons to ArcGIS Polygons\nfunction orientRings (poly) {\n  var output = [];\n  var polygon = poly.slice(0);\n  var outerRing = closeRing(polygon.shift().slice(0));\n  if (outerRing.length >= 4) {\n    if (!ringIsClockwise(outerRing)) {\n      outerRing.reverse();\n    }\n\n    output.push(outerRing);\n\n    for (var i = 0; i < polygon.length; i++) {\n      var hole = closeRing(polygon[i].slice(0));\n      if (hole.length >= 4) {\n        if (ringIsClockwise(hole)) {\n          hole.reverse();\n        }\n        output.push(hole);\n      }\n    }\n  }\n\n  return output;\n}\n\n// This function flattens holes in multipolygons to one array of polygons\n// used for converting GeoJSON Polygons to ArcGIS Polygons\nfunction flattenMultiPolygonRings (rings) {\n  var output = [];\n  for (var i = 0; i < rings.length; i++) {\n    var polygon = orientRings(rings[i]);\n    for (var x = polygon.length - 1; x >= 0; x--) {\n      var ring = polygon[x].slice(0);\n      output.push(ring);\n    }\n  }\n  return output;\n}\n\n// shallow object clone for feature properties and attributes\n// from http://jsperf.com/cloning-an-object/2\nfunction shallowClone (obj) {\n  var target = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      target[i] = obj[i];\n    }\n  }\n  return target;\n}\n\nfunction getId (attributes, idAttribute) {\n  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (\n      key in attributes &&\n      (typeof attributes[key] === 'string' ||\n        typeof attributes[key] === 'number')\n    ) {\n      return attributes[key];\n    }\n  }\n  throw Error('No valid id attribute found');\n}\n\nexport function arcgisToGeoJSON (arcgis, idAttribute) {\n  var geojson = {};\n\n  if (arcgis.features) {\n    geojson.type = 'FeatureCollection';\n    geojson.features = [];\n    for (var i = 0; i < arcgis.features.length; i++) {\n      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n    }\n  }\n\n  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n    geojson.type = 'Point';\n    geojson.coordinates = [arcgis.x, arcgis.y];\n    if (typeof arcgis.z === 'number') {\n      geojson.coordinates.push(arcgis.z);\n    }\n  }\n\n  if (arcgis.points) {\n    geojson.type = 'MultiPoint';\n    geojson.coordinates = arcgis.points.slice(0);\n  }\n\n  if (arcgis.paths) {\n    if (arcgis.paths.length === 1) {\n      geojson.type = 'LineString';\n      geojson.coordinates = arcgis.paths[0].slice(0);\n    } else {\n      geojson.type = 'MultiLineString';\n      geojson.coordinates = arcgis.paths.slice(0);\n    }\n  }\n\n  if (arcgis.rings) {\n    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n  }\n\n  if (\n    typeof arcgis.xmin === 'number' &&\n    typeof arcgis.ymin === 'number' &&\n    typeof arcgis.xmax === 'number' &&\n    typeof arcgis.ymax === 'number'\n  ) {\n    geojson.type = 'Polygon';\n    geojson.coordinates = [[\n      [arcgis.xmax, arcgis.ymax],\n      [arcgis.xmin, arcgis.ymax],\n      [arcgis.xmin, arcgis.ymin],\n      [arcgis.xmax, arcgis.ymin],\n      [arcgis.xmax, arcgis.ymax]\n    ]];\n  }\n\n  if (arcgis.geometry || arcgis.attributes) {\n    geojson.type = 'Feature';\n    geojson.geometry = (arcgis.geometry) ? arcgisToGeoJSON(arcgis.geometry) : null;\n    geojson.properties = (arcgis.attributes) ? shallowClone(arcgis.attributes) : null;\n    if (arcgis.attributes) {\n      try {\n        geojson.id = getId(arcgis.attributes, idAttribute);\n      } catch (err) {\n        // don't set an id\n      }\n    }\n  }\n\n  // if no valid geometry was encountered\n  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n    geojson.geometry = null;\n  }\n\n  if (\n    arcgis.spatialReference &&\n    arcgis.spatialReference.wkid &&\n    arcgis.spatialReference.wkid !== 4326\n  ) {\n    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n  }\n\n  return geojson;\n}\n\nexport function geojsonToArcGIS (geojson, idAttribute) {\n  idAttribute = idAttribute || 'OBJECTID';\n  var spatialReference = { wkid: 4326 };\n  var result = {};\n  var i;\n\n  switch (geojson.type) {\n    case 'Point':\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n      result.spatialReference = spatialReference;\n      break;\n    case 'MultiPoint':\n      result.points = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case 'LineString':\n      result.paths = [geojson.coordinates.slice(0)];\n      result.spatialReference = spatialReference;\n      break;\n    case 'MultiLineString':\n      result.paths = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case 'Polygon':\n      result.rings = orientRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case 'MultiPolygon':\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case 'Feature':\n      if (geojson.geometry) {\n        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);\n      }\n      result.attributes = (geojson.properties) ? shallowClone(geojson.properties) : {};\n      if (geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n      break;\n    case 'FeatureCollection':\n      result = [];\n      for (i = 0; i < geojson.features.length; i++) {\n        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));\n      }\n      break;\n    case 'GeometryCollection':\n      result = [];\n      for (i = 0; i < geojson.geometries.length; i++) {\n        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n      }\n      break;\n  }\n\n  return result;\n}\n\nexport default { arcgisToGeoJSON: arcgisToGeoJSON, geojsonToArcGIS: geojsonToArcGIS };\n"],"names":["closeRing","coordinates","a","b","i","length","pointsEqual","push","ringIsClockwise","ringToTest","pt2","total","rLength","pt1","vertexIntersectsVertex","a1","a2","b1","b2","uaT","ubT","uB","ua","ub","arrayIntersectsArray","j","coordinatesContainCoordinates","outer","inner","intersects","contains","point","l","coordinatesContainPoint","orientRings","poly","output","polygon","slice","outerRing","shift","reverse","hole","shallowClone","obj","target","hasOwnProperty","arcgisToGeoJSON","arcgis","idAttribute","geojson","features","type","x","y","z","points","paths","rings","outerRings","holes","r","ring","uncontainedHoles","pop","contained","convertRingsToGeoJSON","xmin","ymin","xmax","ymax","geometry","attributes","properties","id","keys","key","Error","getId","err","JSON","stringify","spatialReference","wkid","console","warn","geojsonToArcGIS","result","flattenMultiPolygonRings","geometries"],"sourceRoot":""}